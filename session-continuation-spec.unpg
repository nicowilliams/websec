


Network Working Group                                        N. Williams
Internet-Draft                                              Cryptonector
Intended status: Standards Track                       December 31, 2012
Expires: July 4, 2013


   Hypertext Transport Protocol (HTTP) Session Continuation Protocol
            draft-williams-websec-session-continue-proto-00

Abstract

   One of the most often talked about problems in web security is
   "cookies".  Web cookies are a method of associating requests with
   "sessions" that may have been authenticated somehow.  Cookies are a
   form of bearer token that leave much to be desired.  This document
   proposes a session "continuation" protocol for HyperText Transport
   Protocol (HTTP).

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on July 4, 2013.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.


Table of Contents

   1.    Introduction
   2.    Session Keying
   2.1.  Mixing HTTP and HTTPS
   2.2.  Authenticated Session Keying
   2.3.  Unauthenticated Session Keying
   3.    Session Initiation
   4.    Session Scope: Sharing Sessions Across Servers
   5.    Unauthenticated to Authenticated Session Upgrade
   6.    Session Continuation
   6.1.  Alternative: Define Session Scheme for WWW-Authenticate
   7.    Logout
   8.    Inquiring Session Status
   9.    Analysis
   10.   IANA Considerations
   11.   Security Considerations
   12.   References
   12.1. Normative References
   12.2. Informative References
         Author's Address


1.  Introduction

   The motivation for this protocol is described in
   [I-D.williams-websec-session-continue-prob].

   We define a protocol for cryptographic "session continuation" for
   HyperText Transport Protocol (HTTP) [RFC2616].  Session continuation
   is the act of binding an HTTP request to a "session".  A "session"
   consists of all the HTTP requests by a given user (possibly an
   authenticated user, or possibly an anonymous user).  This protocol is
   a cryptographic protocol that aims to meet all the requirements given
   in [I-D.williams-websec-session-continue-prob].

   The protocol consists of:

   o  a request header carrying a keyed Message Authentication Code
      (MAC) that prove possession of a shared session key (shared
      between the user and the server);

   o  a response header advertising a default session scope to clients;

   o  a session identification in the form of a URI;

   o  optional server-side statelessness by storing state on the client-
      side, encrypted in a secret key known to the server;

   o  a request header for requesting the establishment of a session;

   o  a response header for indicating the establishment of a session,
      and including a session URI and any optional state to be repeated
      by the client.


2.  Session Keying

   There are two methods for keying an HTTP session:

   o  session keys are output by HTTP authentication;

   o  or session keys are asserted by the client;

   For the key assertion method TLS with confidentiality protection is
   clearly REQUIRED for security.  We've considered the possibility of
   using Diffie-Hellman key agreement or RSA key transport, but as that
   would duplicate functionality that is in TLS we consider that out of
   scope for the time being.  (We could also use the TLS extractor to
   generate keys, but that would be an unnecessary complication and
   would provide very little additional value.)

   [XXX Should we have distinct session keys for request and response
   MACs?]

   In either case a single master key is generated or asserted and a Key
   Derivation Function (KDF) [RFC5869] is used to generate the session
   keys for use with HTTP and HTTPS.  Keys are derived by applying the
   negotiated KDF to the master key (output by the HTTP authentication
   method, or asserted) and either "secure" or "insecure" as the salt.
   All session keys for MAC algorithms specified here SHALL be 128 bits
   long.

2.1.  Mixing HTTP and HTTPS

   We expect that many sites will continute to mix HTTP and HTTPS for
   various reasons.  To make this possible sessions will have two
   session keys: one for use over HTTPS, and the other for use over
   HTTP.

2.2.  Authenticated Session Keying

   When an HTTP client uses HTTP authentication, and the authentication
   mechanism used can establish a session key, then the client SHOULD
   request session initiation using a shared session key output by the
   HTTP authentication mechanism.  The client MUST send the session
   initiation header concurrently with the last HTTP authentication
   message.

2.3.  Unauthenticated Session Keying

   Sessions for unauthenticated users may appear to make little sense at
   first.  This is useful, for example, and just as web cookies are, for
   tracking "shopping carts" when a user is window shopping, so to
   speak.

   For unauthenticated session initiation the client merely requests the
   creation of a session with an asserted session key, for lack of a
   better choice.


3.  Session Initiation

   Sessions are always initiated by the client by including a Session-
   Init header in the client's request carrying the client's proposal
   for a session.

   Servers that support sessions will respond by creating a session and
   returning a session ID URI.

   The Session-Init proposal header's value consists of a comma-
   separated list of proposal parameters:

      session-param = token "=" ( token | quoted-string )
      Session-Init = 1#session-param

                   Figure 1: Session-Init request header

   The following session parameters are defined:

   Key-Method  The type of keying: "auth" (key will be output by HTTP
      authentication), "c-assert" (key is asserted in this Session-Init)
      or "s-assert" (the server is expected to assert a key).  In the
      "auth" case the Session-Init MUST also carry a nonce and a MAC.

   Key  The key that the client asserts, if the client asserts a key.

   MAC-Algs  The MAC algorithms supported by the client.  This document
      defines only "HMAC-SHA-1" (HMAC with SHA-1), "HMAC-SHA-1-96" (HMAC
      with SHA-1 and truncation to 96 bits), "HMAC-SHA256" (HMAC with
      SHA256), and "HMAC-SHA256-128" (HMAC with SHA256 and truncation to
      128 bits).  All of these use HMAC [RFC2104].  Clients and servers
      MUST support HMAC-SHA-1-96 and HMAC-SHA256-128.  If absent the
      default value is "HMAC-SHA256-128".

   KDF-Algs  A list of KDF algorithms.  The following are specified
      here: "HKDF-SHA-1" (HKDF [RFC5869] with SHA-1) and "HKDF-SHA256"
      (HKDF with SHA256).  Clients and servers MUST support HKDF-SHA256.
      If absent the default value is HKDF-SHA256.

   Channel-Binding-Types  A comma-separated list of channel binding
      [RFC5056] types.  Clients and servers MUST support 'tls-server-
      end-point' [RFC5929] when using HTTPS.

   nonce  A 128-bit nonce, base64-encoded.

   Previous-Session-URI  The URI of a previous session.  See Section 5.

   Previous-Session-State  The session state for the previous session,
      if any.  See Section 5.

   MAC-<MAC-alg>-<CB-type>  A base64-encoded MAC (in the given
      algorithm) of the Session-Init header value (excluding the MAC
      session-params), the nonce, the channel binding for the given
      channel binding type, and the previous session URI and state, if
      any.  The items to be MACed are base64-encoded, then concatenated
      with commas in the ordered mentioned in the previous sentence,
      then the keyed MAC is applied.

   Req-MAC-Secure-Content  A comma-separated list of indicators of what
      request content is to be MACed when using HTTPS.

   Resp-MAC-Secure-Content  A comma-separated list of indicators of what
      response content is to be MACed when using HTTPS.  If empty then
      the responses for this session over HTTPS will not contain a MAC
      (none is needed since if the channel binding is correct in the
      request then there is no MITM and TLS provides all the necessary
      protection).

   Req-MAC-Insecure-Content  A comma-separated list of indicators of
      what request content is to be MACed.

   Resp-MAC-Insecure-Content  A comma-separated list of indicators of
      what response content is to be MACed.

   Insecure-Allowed  If present the value MUST be "true", and indicates
      that HTTP and HTTPS are both allowed for this session.  Otherwise
      only HTTPS is allowed for this session.

   The MAC-Content indicators are:

   Start  The message start line.

   CB Channel binding.

   Body  The body of the message.  The content transfer encoding (e.g.
      chunked) is ignored for the purpose of determining the content.

   H-<header-name>  The given header name.

   The server responds with a Session-Assign header:

      session-URI = <URI>
      session-state = <base64 encoding of server-side state>
      Session-Assign = (1#session-param ",")

                 Figure 2: Session-Assign response header

   The session-params for Session-Assign are:

   Key  The server-asserted key, if the client requested a server-
      asserted key.

   MAC-Alg  The name of the MAC algorithm selected by the server from
      the client's proposal (REQUIRED).

   MAC  A MAC of the client's Session-Init header and the server's
      Session-Assign header (excluding the MAC session-param).  This is
      OPTIONAL when using HTTPS, REQUIRED when using HTTP.  [XXX
      expand].

   URI  The URI of the session (REQUIRED).

   State  Server-side state to be stored on the client (OPTIONAL).

   Host-Scope  A DNS domainname (in A-label form) that the session can
      be used with.  Multiple Scope parameters are allowed.  If the
      domainname starts with a '.' then the session may be used with all
      server hosts whose domainnames are sub-domains of the given Host-
      Scope domainname.


4.  Session Scope: Sharing Sessions Across Servers

   A service might be composed of multiple related servers, each with a
   different hostname.  As a result the service may require a client to
   use the same session across the service's component servers.  We
   provide a mechanism by which the server may indicate a set of such
   servers to the client: the Host-Scope session-param in the server's
   Session-Assign response header.

   [XXX We need a way to constrain this for privacy protection reasons.
   It's not yet clear how the client can judge which Host-Scope
   paramters to accept or ignore, only that must be allowed to do so.]

   To facilitate interoperable session sharing across heterogeneous
   server implementations we define a session resource -named by its
   session URI- that can be obtained with a properly-authenticated GET
   by authorized entities.  The session resource's representation is a
   application/json document type, containing a JSON-serialized
   associative array with the following REQUIRED keys:

   Master-Key  The session's master key, base64-encoded.

   MAC-Alg  The MAC algorithm for this session.

   [XXX We probably want each server to see a different master key, in
   which case we probably want to use a KDF with the server's hostname
   as part of the salt.]

   [XXX We probably want to define some OPTIONAL keys, such as "User",
   "User-URI", "HTTP-Auth-Scheme-Used", "HTTP-Auth-Scheme-<param>", and
   so on.]


5.  Unauthenticated to Authenticated Session Upgrade

   A client might first establish an unauthenticated session then
   authenticate the user later.  When authentication is done the client
   might wish to preserve any state associated with the preceding
   unauthenticated session.  The client does this by sending a Session-
   Init at authentication time with a 'Previous-Session-URI' session-
   param and, if there was server-assigned session state, a 'Previous-
   Session-State' session-param.


6.  Session Continuation

   Once a session is established the client binds requests to sessions
   as described here.

   There are two cases: HTTPS and HTTP.  In both cases the client adds a
   header

   For the HTTPS case the client adds a "Session" header to its requests
   with the following content: the session identifier assigned by the
   server, a nonce generated by the client, and a MAC of the nonce and
   the TLS channel bindings.

   The value of the Session header consists of a base64-encoded 128-bit
   nonce and a MAC, using the session's MAC algorithm, of the nonce and
   the channel binding, each base64-encoded then concatenated in that
   order:

      nonce = <base64-encoded 128-bit nonce>
      MAC = <b64 MAC taken over b64-nonce || b64-CB [|| content]>
      Session = nonce "," MAC

                         Figure 3: Session header

   Where the response must carry a Session header, the form of the value
   is the same as for requests.

   The MAC is taken over the nonce, the channel bindings, and the
   content as specified in the Session-Init header used to create this
   session.

   [XXX Add text indicating that headers to be MACed are to be encoded
   per-DKIM.]

6.1.  Alternative: Define Session Scheme for WWW-Authenticate

   One possibility that has some appeal would be to define a new HTTP
   authentication scheme called "Session" (say) and use that instead of
   the "Session" header defined above.  The primary advantage to the
   WWW-Authenticate approach is that it fits the existing HTTP
   authentication framework, allowing a server to present to an
   application the user authentication information embedded in the
   session state as if the user were re-authenticated in each request.
   Session continuation can then be seen as a form of fast re-
   authentication.


7.  Logout

   To logout the client SHOULD perform a DELETE of the session URI.


8.  Inquiring Session Status

   The client MAY do a GET of the session URI.  The semantics of the
   response body for this are not specified here.  As explained in
   Section 4, servers also may GET a session URI; see Section 4 for more
   details.


9.  Analysis

   Quite clearly this protocol meets requirements 1, 2, 3, and 5 from
   [I-D.williams-websec-session-continue-prob].

   The security requirements are also met:

   requirement 4  The active cookie recovery attacks on TLS are adaptive
      chosen plaintext attacks.  These attacks depend on the cookies
      sent by the client being the same in every request.  This protocol
      uses MAC of at least channel bindings data (which doesn't change
      for any one connection) salted (so to speak) with a nonce.  This
      use of nonces causes the MAC sent to be different for each
      request, which defeats the known cookie recovery attacks on TLS.
      Note that we assume confidentiality protection from TLS; clients
      MUST NOT negotiate cipher suites that provide no confidentiality
      protection.

   requirement 6  This is clearly met by the use of a MAC keyed with a
      session key not available to attackers.  This clearly depends on
      implementations having decent entropy sources, but this is no
      different than for TLS.  Note, however, that insecure session
      initiation with key assertion is clearly insecure relative to
      passive attackers, as well as active attackers that can redirect
      packet flows so they can observe session initiation.

   requirement_7  This is clearly met by using a cryptographically
      secure KDF to derive distinct keys for use with HTTP and HTTPS.

   requirement_8  The use of channel bindings as an input to the MAC
      meets this requirement.

   requirement_9  This requirement is clearly met by having DELETE of a
      session URI terminate a session.  It is important that clients
      promptly destroy any remnant of deleted sessions' state so that
      servers get no benefit from not deleting sessions when the clients
      demand it.

   requirement_10  This is clearly met by using headers that proxies
      will pass unmodified.


10.  IANA Considerations

   This document creates a number of new HTTP request and response
   headers.  These headers will need to be added to the HTTP header
   registry: <TBD>.


11.  Security Considerations

   This session continuation protocol appears to meet the requirements
   outlined in [I-D.williams-websec-session-continue-prob].  [XXX Add
   analysis.  In particular explain how MAC(CB + nonce) is sufficient to
   defeat BEAST and CRIME.]

   This proposal meets security requirements from the problem statement
   [I-D.williams-websec-session-continue-prob].  See Section 9 for
   details.

   [...]


12.  References

12.1.  Normative References

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              February 1997.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5056]  Williams, N., "On the Use of Channel Bindings to Secure
              Channels", RFC 5056, November 2007.

   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", RFC 5929, July 2010.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869, May 2010.

   [I-D.williams-websec-session-continue-prob]
              Williams, N., "Hypertext Transport Protocol (HTTP) Session
              Continuation: Problem Statement",
              draft-williams-websec-session-continue-prob-00 (work in
              progress), January 2013.

12.2.  Informative References

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, June 1999.

   [RFC5849]  Hammer-Lahav, E., "The OAuth 1.0 Protocol", RFC 5849,
              April 2010.

   [I-D.ietf-oauth-v2]
              Hardt, D., "The OAuth 2.0 Authorization Framework",
              draft-ietf-oauth-v2-31 (work in progress), August 2012.

   [I-D.hallambaker-httpintegrity]
              Hallam-Baker, P., "HTTP Integrity Header",
              draft-hallambaker-httpintegrity-02 (work in progress),
              November 2012.


Author's Address

   Nicolas Williams
   Cryptonector, LLC

   Email: nico@cryptonector.com

